//---------------------------------------------------------------------------
// Default Corne script.
//---------------------------------------------------------------------------

// Steno
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |        |  S1  |   T  |   P  |   H  |  *1  |        |  *2  |   F  |   P  |   L  |   T  |    D   |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  S2  |   K  |   W  |   R  |  *3  |        |  *4  |   R  |   B  |   G  |   S  |    Z   |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// | QWERTY |      |      |      |      |      |        |      |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |  #1  |   A  |   O  |  |   E  |   U  |  #2  |
//                           `--------------------'  `--------------------'
//
// * Tapping QWERTY key will switch to QWERTY mode
// * Holding it down and pressing other buttons will cause the keyboard to return to steno mode when
//   releasing it. This will also give access to the Symbols, Navigation and Function layers by
//   pressing those keys on the QWERTY layer.

// QWERTY
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |   Tab  |   Q  |   W  |   E  |   R  |   T  |        |   Y  |   U  |   I  |   O  |   P  |  Bksp  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Ctrl/Esc|   A  |   S  |   D  |   F  |   G  |        |   H  |   J  |   K  |   L  | ;  : |  '  "  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Shf/Sten|   Z  |   X  |   C  |   V  |   B  |        |   N  |   M  | ,  < | .  > | /  ? | RShift |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt |Nav/Sp|  | Space|Fn/Ent| Sym  |
//                           `--------------------'  `--------------------'
//
// For keys marked with two options, holding or pressing with other keys will cause the first option
// to be used, tapping briefly will trigger the second.
//
// Tapping right shift twice will turn on single word capitalization.
// Tapping right shift three times will turn on and off caps lock.

//
// Symbols
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |    `   |  1   |  2   |  3   |  4   |  5   |        |   6  |  7   |  8   |  9   |  0   |   =    |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |    ~   |  !   |  @   |  #   |  $   |  %   |        |   ^  |  &   |  *   |  (   |  )   |   +    |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  \   |  |   |  -   |  [   |  {   |        |   }  |  ]   |  _   |  .   |  /   |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt | Ctrl |  |      |      |      |
//                           `--------------------'  `--------------------'
//

//
// Function
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |        |  F9  | F10  | F11  | F12  |      |        |      |      |      |      |      |        |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  F5  |  F6  |  F7  |  F8  |      |        |      | Shift| Ctrl |  Alt |  GUI |        |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  F1  |  F2  |  F3  |  F4  |      |        |      |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |      |      |  |      |      |      |
//                           `--------------------'  `--------------------'

//
// Navigation/Media
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |        |      |      |      |      |      |        | Vol+ | BkSp |   ↑  | Del  | PgUp |  Home  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  GUI |  Alt | Ctrl | Shift|      |        | Vol- |  ←   |   ↓  |   →  | PgDn |   End  |
// |--------+------+------+------+------+------+        +------+------+------+------+------+--------|
// |        |      |      |      |      |      |        | Mute |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |      |      |  | Space| Enter|      |
//                           `--------------------'  `--------------------'
//

//
// Settings - pressing both Sym and Fn together.
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |StrkCnt |      |      |Embedd|      |      |        |Speed+|      |Brght+| Sat+ | Hue+ |HueSprd+|
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |      |      |Gemini|      |      |        |Speed-|      |Brght-| Sat- | Hue- |HueSprd-|
// |--------+------+------+------+------+------+        +------+------+------+------+------+--------|
// |        |      |      |PloHID|      |      |        |      |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |      |      |  |      |      |      |
//                           `--------------------'  `--------------------'
//


//---------------------------------------------------------------------------
// USB Scan code values.
//
// These constants are used with inbuilt functions:
//  * func pressScanCode(SC_xxx)
//  * func releaseScanCode(SC_xxx)
//  * func tapScanCode(SC_xxx)
//  * func isScanCodePressed(SC_xxx) var
//
//---------------------------------------------------------------------------

const SC_NONE = 0;

const SC_A = 0x04;
const SC_B = 0x05;
const SC_C = 0x06;
const SC_D = 0x07;
const SC_E = 0x08;
const SC_F = 0x09;
const SC_G = 0x0a;
const SC_H = 0x0b;
const SC_I = 0x0c;
const SC_J = 0x0d;
const SC_K = 0x0e;
const SC_L = 0x0f;
const SC_M = 0x10;
const SC_N = 0x11;
const SC_O = 0x12;
const SC_P = 0x13;
const SC_Q = 0x14;
const SC_R = 0x15;
const SC_S = 0x16;
const SC_T = 0x17;
const SC_U = 0x18;
const SC_V = 0x19;
const SC_W = 0x1a;
const SC_X = 0x1b;
const SC_Y = 0x1c;
const SC_Z = 0x1d;

const SC_1 = 0x1e;
const SC_2 = 0x1f;
const SC_3 = 0x20;
const SC_4 = 0x21;
const SC_5 = 0x22;
const SC_6 = 0x23;
const SC_7 = 0x24;
const SC_8 = 0x25;
const SC_9 = 0x26;
const SC_0 = 0x27;

const SC_ENTER = 0x28;
const SC_ESC = 0x29;
const SC_BACKSPACE = 0x2a;
const SC_TAB = 0x2b;
const SC_SPACE = 0x2c;
const SC_MINUS = 0x2d;
const SC_EQUAL = 0x2e;
const SC_L_BRACKET = 0x2f;
const SC_R_BRACKET = 0x30;
const SC_BACKSLASH = 0x31;
const SC_HASH_TILDE = 0x32;
const SC_SEMICOLON = 0x33;
const SC_APOSTROPHE = 0x34;
const SC_GRAVE = 0x35;
const SC_COMMA = 0x36;
const SC_DOT = 0x37;
const SC_SLASH = 0x38;
const SC_CAPS = 0x39;

const SC_F1 = 0x3a;
const SC_F2 = 0x3b;
const SC_F3 = 0x3c;
const SC_F4 = 0x3d;
const SC_F5 = 0x3e;
const SC_F6 = 0x3f;
const SC_F7 = 0x40;
const SC_F8 = 0x41;
const SC_F9 = 0x42;
const SC_F10 = 0x43;
const SC_F11 = 0x44;
const SC_F12 = 0x45;

const SC_SYS_RQ = 0x46;
const SC_SCROLL_LOCK = 0x47;
const SC_PAUSE = 0x48;
const SC_INSERT = 0x49;
const SC_HOME = 0x4a;
const SC_PAGE_UP = 0x4b;
const SC_DELETE = 0x4c;
const SC_END = 0x4d;
const SC_PAGE_DOWN = 0x4e;
const SC_RIGHT = 0x4f;
const SC_LEFT = 0x50;
const SC_DOWN = 0x51;
const SC_UP = 0x52;

const SC_NUM_LOCK = 0x53;
const SC_KP_SLASH = 0x54;
const SC_KP_ASTERISK = 0x55;
const SC_KP_MINUS = 0x56;
const SC_KP_PLUS = 0x57;
const SC_KP_ENTER = 0x58;
const SC_KP_1 = 0x59;
const SC_KP_2 = 0x5a;
const SC_KP_3 = 0x5b;
const SC_KP_4 = 0x5c;
const SC_KP_5 = 0x5d;
const SC_KP_6 = 0x5e;
const SC_KP_7 = 0x5f;
const SC_KP_8 = 0x60;
const SC_KP_9 = 0x61;
const SC_KP_0 = 0x62;
const SC_KP_DOT = 0x63;

const SC_BACKSLASH_PIPE = 0x64;
const SC_COMPOSE = 0x65;
const SC_POWER = 0x66;
const SC_KP_EQUAL = 0x67;

const SC_F13 = 0x68;
const SC_F14 = 0x69;
const SC_F15 = 0x6a;
const SC_F16 = 0x6b;
const SC_F17 = 0x6c;
const SC_F18 = 0x6d;
const SC_F19 = 0x6e;
const SC_F20 = 0x6f;
const SC_F21 = 0x70;
const SC_F22 = 0x71;
const SC_F23 = 0x72;
const SC_F24 = 0x73;

const SC_OPEN = 0x74;
const SC_HELP = 0x75;
const SC_MENU = 0x76;
const SC_SELECT = 0x77;
const SC_STOP = 0x78;
const SC_AGAIN = 0x79;
const SC_UNDO = 0x7a;
const SC_CUT = 0x7b;
const SC_COPY = 0x7c;
const SC_PASTE = 0x7d;
const SC_FIND = 0x7e;
const SC_MUTE = 0x7f;
const SC_VOLUME_UP = 0x80;
const SC_VOLUME_DOWN = 0x81;

const SC_KP_COMMA = 0x85;

const SC_KP_LEFT_PAREN = 0xb6;
const SC_KP_RIGHT_PAREN = 0xb7;

const SC_L_CTRL = 0xe0;
const SC_L_SHIFT = 0xe1;
const SC_L_ALT = 0xe2;
const SC_L_META = 0xe3;
const SC_R_CTRL = 0xe4;
const SC_R_SHIFT = 0xe5;
const SC_R_ALT = 0xe6;
const SC_R_META = 0xe7;

const SC_MEDIA_PLAY_PAUSE = 0xe8;
const SC_MEDIA_STOP_CD = 0xe9;
const SC_MEDIA_PREVIOUS_SONG = 0xea;
const SC_MEDIA_NEXT_SONG = 0xeb;
const SC_MEDIA_EJECT_CD = 0xec;
const SC_MEDIA_VOLUME_UP = 0xed;
const SC_MEDIA_VOLUME_DOWN = 0xee;
const SC_MEDIA_MUTE = 0xef;
const SC_MEDIA_WWW = 0xf0;
const SC_MEDIA_BACK = 0xf1;
const SC_MEDIA_FORWARD = 0xf2;
const SC_MEDIA_STOP = 0xf3;
const SC_MEDIA_FIND = 0xf4;
const SC_MEDIA_SCROLL_UP = 0xf5;
const SC_MEDIA_SCROLL_DOWN = 0xf6;
const SC_MEDIA_EDIT = 0xf7;
const SC_MEDIA_SLEEP = 0xf8;
const SC_MEDIA_COFFEE = 0xf9;
const SC_MEDIA_REFRESH = 0xfa;
const SC_MEDIA_CALC = 0xfb;

//---------------------------------------------------------------------------
// javelin-steno steno key values.
//
// These constants are used with inbuilt functions:
//  * func pressStenoKey(SK_xxx)
//  * func releaseStenoKey(SK_xxx)
//  * func isStenoKeyPressed(SK_xxx) var
//
//---------------------------------------------------------------------------

const SK_NONE = -1;
const SK_S1 = 0;
const SK_S2 = 1;
const SK_TL = 2;
const SK_KL = 3;
const SK_PL = 4;
const SK_WL = 5;
const SK_HL = 6;
const SK_RL = 7;
const SK_A = 8;
const SK_O = 9;
const SK_STAR1 = 10;
const SK_STAR2 = 11;
const SK_STAR3 = 12;
const SK_STAR4 = 13;
const SK_E = 14;
const SK_U = 15;
const SK_FR = 16;
const SK_RR = 17;
const SK_PR = 18;
const SK_BR = 19;
const SK_LR = 20;
const SK_GR = 21;
const SK_TR = 22;
const SK_SR = 23;
const SK_DR = 24;
const SK_ZR = 25;
const SK_NUM1 = 26;
const SK_NUM2 = 27;
const SK_NUM3 = 28;
const SK_NUM4 = 29;
const SK_NUM5 = 30;
const SK_NUM6 = 31;
const SK_NUM7 = 32;
const SK_NUM8 = 33;
const SK_NUM9 = 34;
const SK_NUM10 = 35;
const SK_NUM11 = 36;
const SK_NUM12 = 37;
const SK_FUNCTION = 38;
const SK_POWER = 39;
const SK_RES1 = 40;
const SK_RES2 = 41;

//---------------------------------------------------------------------------
// Other functions:
//
//  * func releaseAll()
//    - releases all pressed scan codes and steno keys.
//  * func pressAll()
//    - call all press scripts for buttons that are pressed.
//  * func isInPressAll() var
//    - returns non-zero if a pressAll is being processed.
//  * func isButtonPressed(buttonIndex) var
//    - Returns 1 if the physical button is pressed.
//  * func checkButtonState("01 10") var
//    - Returns if the current button state matches the string.
//    - 0 = not pressed, space = ignore, all others = pressed.
//      - The example string checks that:
//        - button 0 is off.
//        - button 1 is on.
//        - button 3 is on.
//        - button 4 is off.
//    - The string should be the same length as the number of buttons.
//  * func sendText("Example")
//    - Sends all of the key presses required to emit the specified string.
//    - e.g.,
//      - Press Shift
//      - Press E
//      - Release E
//      - Release Shift
//      - Press X
//      - Release X
//      - etc.
//  * func setRgb(id, r, g, b)
//    - For boards with rgb lights, sets an individual light to the r, g, b.
//  * func setHsv(id, h, s, v)
//    - For boards with rgb lights, sets an individua light to h, s, v.
//      - h = hue,        0-65536 represents 0°  - 360°
//      - s = saturation, 0-256   represents 0.0 - 1.0
//      - v = value,      0-255   represents 0.0 - 1.0
//  * func getTime() var
//    - Returns milliseconds since launch.
//  * func getLedStatus(id) var
//    - Returns whether the led statues is on. See LED_STATUS constants.
//
// releaseAll() and pressAll() are useful for changing modes/layers, e.g.:
//
// if (layer != SYMBOL_LAYER) {
//   releaseAll();
//   layer = SYMBOL_LAYER;
//   pressAll();
// }
//
// This will allow keys on the symbol layer to be pressed 'out-of-order' but
// still behave as expected.
//
// It is important that every pressAll() call in an onPress handler is guarded
// to prevent infinite recursion, since the onPress will be re-run even for the
// current key. The easiest way to do this is using isInPressAll() function.
//

const LED_STATUS_NUM_LOCK = 0;
const LED_STATUS_CAPS_LOCK = 1;
const LED_STATUS_SCROLL_LOCK = 2;
const LED_STATUS_COMPOSE = 3;
const LED_STATUS_KANA = 4;

//---------------------------------------------------------------------------
// Drawing methods:
//  * func clearDisplay(displayId)
//  * func setAutoDraw(displayId, autoDrawId)
//  * func setDrawColor(displayId, color)
//  * func drawPixel(displayId, x, y)
//  * func drawLine(displayId, x1, y1, x2, y2)
//  * func drawRect(displayId, left, top, right, bottom)
//  * func drawImage(displayId, x, y, image)
//  * func drawText(displayId, x, y, fontId, alignment, text)

const AUTO_DRAW_NONE = 0;
const AUTO_DRAW_PAPER_TAPE = 1;
const AUTO_DRAW_STENO_LAYOUT = 2;
const AUTO_DRAW_WPM = 3;

const TEXT_ALIGNMENT_LEFT = 0;
const TEXT_ALIGNMENT_MIDDLE = 1;
const TEXT_ALIGNMENT_RIGHT = 2;

//---------------------------------------------------------------------------
//
// Corne button layout:
//
// Button indexes
//
//      0   1   2   3   4   5    |     6   7   8   9  10  11
//     12  13  14  15  16  17    |    18  19  20  21  22  23
//     24  25  26  27  28  29    |    30  31  32  33  34  35
//                   36  37  38  |  39  40  41
//
//
//---------------------------------------------------------------------------
// Example global variable:
//   var layers = 0;

// Example local functions:
//
//   func useNavLayer() var {
//     return isButtonPressed(22);
//   }
//
//   func handlePress(stenoKey, navKey) {
//     if (useNavLayer()) {
//       pressScanCode(navKey);
//     } else {
//       pressStenoKey(stenoKey);
//     }
//   }
//
// Then the onPress handler could call handlePress(SK_S1 | KEY_STENO, SC_TAB);

//---------------------------------------------------------------------------
// The script needs to have onPress## and onRelease## functions for every
// physical button.
//---------------------------------------------------------------------------

const QWERTY_LAYER = 0;
const STENO_MASK = 1;
const SYMBOL_MASK = 2;
const FUNCTION_MASK = 4;
const NAV_MASK = 8;

var layer = STENO_MASK;
var pressCount = 0;
var speed = 1;
var hueSpread = 4;
var hueShift = 0;
var brightness = 3;
var saturation = 5;
var lastActionTime = 0;
var lastCapsLockStatus = 0;

// Layer Tap Forgiveness.
//
// To avoid unintended navigation/function layer presses, the following
// sequence of events is interpreted as a press on the qwerty layer instead:
//
//     Layer key press        Key press        Layer key release
//            |                   |                     |
//   t ---------------------------------------------------------->
//           T0                  T1                    T2
//
// For this to happen, the time between T0 and T1 has to be less than 100 ms,
// and the time between T1 and T2 has to be less than 50 ms.
//
// Mechanics:
//  1. When a layer button is pressed, record a layerPressTimestamp.
//  2. When a key is pressed within 100ms and there is no recorded
//     keypress, then the layer and qwerty key are recorded with
//     qwertyPressTimestamp. If there is already a recorded keypress, press the
//     deferred layer key and immediately press the newer key. If a keypress
//     occurs outside of 100ms, process normally.
//  2. When the layer button is released, if there is a deferredQwertyKey
//     recorded timestamp within 50ms of qwertyPressTimestamp, then press space
//     then the non-nav key. This is detected in release when NAV_MASK is on,
//     but isButtonPressed(38) returns false, and the key is emitted in the
//     release script for the layer key.
//  3. When a key is released, if there is a deferred key, press it first.
//  4. On tick update, if more than 50ms after qwertyPressTimestamp has elapsed,
//     then issue the deferredQwertyKey.
const LAYER_PRESS_TO_KEY_PRESS_THRESHOLD = 100;
const KEY_PRESS_TO_LAYER_RELEASE_THRESHOLD = 50;
const NAV_BUTTON = 38;
const FUNCTION_BUTTON = 40;

var deferredLayerKey = 0;
var deferredQwertyKey = 0;
var navLayerPressTimestamp;
var functionLayerPressTimestamp;
var qwertyPressTimestamp;

const KEY_STENO = 0x200;
const KEY_SHIFT = 0x100;
const TAP_THRESHOLD = 200; // milliseconds for keys that have alternates
const SCREEN_OFF_TIMEOUT = 30000; // 30 seconds.

const STENO_MODE_EMBEDDED = 0;
const STENO_MODE_GEMINI = 1;

var wordCaps = 0;
var stenoMode = STENO_MODE_EMBEDDED;

const SHIFT_IMAGE = [[
  10 10
  00 01 80 01 c0 01 e0 01 f0 7f f8 7f fc 7f fe 7f
  fe 7f fc 7f f8 7f f0 7f e0 01 c0 01 80 01 00 01
]];

const CONTROL_IMAGE = [[
  10 10
  00 00 00 00 40 00 60 00 30 00 18 00 0c 00 06 00
  06 00 0c 00 18 00 30 00 60 00 40 00 00 00 00 00
]];

const ALT_IMAGE = [[
  10 10
  00 00 00 30 00 30 00 30 00 30 00 38 00 1e 80 07
  e0 01 78 30 1c 30 0c 30 0c 30 0c 30 0c 30 00 00
]];

const COMMAND_IMAGE = [[
  10 10
  00 00 3c 3c 7e 7e 66 66 66 66 fe 7f fc 3f 60 06
  60 06 fc 3f fe 7f 66 66 66 66 7e 7e 3c 3c 00 00
]];

const CAPS_LOCK_IMAGE = [[
  10 10
  00 01 80 01 c0 01 e0 01 f0 67 f8 67 fc 67 fe 67
  fe 67 fc 67 f8 67 f0 67 e0 01 c0 01 80 01 00 01
]];

const STENO_IMAGE = [[
  20 20 fe ff 1f 00 fe ff 7f 00 fe ff ff 01 fe ff
  ff 03 fe ff ff 07 fe ff ff 0f fe f9 f3 1f fe f0
  e1 1f fe f0 e1 3f fe e1 f0 3f fe e3 f8 7f fe 47
  fc 7f fe 07 fc 7f fe 0f fe 7f 0e 00 00 7e 0e 00
  00 7e 0e 00 00 7e fe 0f fe 7f fe 07 fc 7f fe 47
  fc 7f fe e3 f8 7f fe e1 f0 3f fe f0 e1 3f fe f0
  e1 1f fe f9 f3 1f fe ff ff 0f fe ff ff 07 fe ff
  ff 03 fe ff ff 01 fe ff 7f 00 fe ff 1f 00 00 00
  00 00
]];

const FUNCTION_IMAGE = [[
  20 20
  f0 ff ff 0f f8 ff ff 1f 0c 00 00 30 06 00 00 60
  03 00 00 c0 03 00 06 c0 03 00 06 c0 03 c0 ff c7
  03 e0 ff c7 03 60 06 c0 03 60 06 c0 03 00 00 c0
  03 00 fe c7 03 00 fe c7 03 00 0c c0 03 00 06 c0
  03 00 0e c0 03 00 fc c7 03 00 f8 c7 03 00 00 c0
  03 00 00 c0 03 00 00 c0 03 00 00 c0 03 00 00 c0
  03 00 00 c0 03 00 00 c0 03 00 00 c0 03 00 00 c0
  06 00 00 60 0c 00 00 30 f8 ff ff 1f f0 ff ff 0f
]];

const QWERTY_IMAGE = [[
  20 20 00 00 00 00 00 00 08 00 00 00 0c 00 00 00
  0f 00 00 c0 0f 00 00 f0 09 00 00 bc 00 00 80 8f
  00 00 80 bf 00 00 00 fc 08 00 00 f0 0f 00 00 c0
  0f 00 00 00 0e 00 00 00 08 00 80 00 08 00 80 ff
  0f 00 80 ff 0f 00 00 30 0c 00 00 10 08 00 00 30
  0c 00 00 f0 0f 00 00 e0 07 00 00 00 00 00 00 e0
  07 00 00 f0 0f 00 00 30 0c 00 00 10 08 00 00 30
  0c 00 00 70 0e 00 00 60 06 00 00 00 00 00 00 00
  00 00
]];

const SYMBOL_IMAGE = [[
  20 20 00 00 00 00 00 00 00 00 18 00 00 00 18 00
  00 00 1c 00 00 00 fe 3f ff 1b fe 3f ff 1b fe 3f
  ff 1b 00 00 00 00 00 00 fc 0f 00 00 fe 1f 1c 38
  ff 3f 1e 3c 07 38 1e 3e f3 33 06 3f f3 37 86 37
  f3 37 c6 33 07 36 fe 31 ff 3b fe 30 fe 3b 3c 30
  fc 19 00 00 00 00 1c 0c 00 03 1e 1c 18 3f 1e 3c
  f8 3f c6 38 ff 3f c6 30 ff 03 e6 30 1f 3f fe 39
  f8 3f fe 3f ff 3f bc 1f ff 03 00 0e 1f 03 00 00
  18 00
]];

const NAVIGATION_IMAGE = [[
  20 20
  00 00 00 00 00 80 01 00 00 40 02 00 00 20 04 00
  00 10 08 00 00 08 10 00 00 3c 3c 00 00 20 04 00
  00 20 04 00 00 20 04 00 40 20 04 02 60 e0 07 06
  50 00 00 0a c8 0f f0 13 04 08 10 20 02 08 10 40
  02 08 10 40 04 08 10 20 c8 0f f0 13 50 00 00 0a
  60 e0 07 06 40 20 04 02 00 20 04 00 00 20 04 00
  00 20 04 00 00 3c 3c 00 00 08 10 00 00 10 08 00
  00 20 04 00 00 40 02 00 00 80 01 00 00 00 00 00
]];

const SETTINGS_IMAGE = [[
  20 20 00 00 00 00 00 c0 03 00 00 e0 07 00 00 e0
  07 00 c0 e0 07 03 e0 f3 cf 07 f0 ff ff 0f f0 ff
  ff 0f e0 ff ff 07 e0 ff ff 07 c0 ff ff 03 c0 7f
  fe 03 e0 1f f8 07 fc 0f f0 3f fe 0f f0 7f fe 07
  e0 7f fe 07 e0 7f fe 0f f0 7f fc 0f f0 3f e0 1f
  f8 07 c0 7f fe 03 c0 ff ff 03 e0 ff ff 07 e0 ff
  ff 07 f0 ff ff 0f f0 ff ff 0f e0 f3 cf 07 c0 e0
  07 03 00 e0 07 00 00 e0 07 00 00 c0 03 00 00 00
  00 00
]];

const SPEED_IMAGE = [[
  10 10 80 1f e0 3f f0 30 38 30 18 30 1c 30 0c 30
  0c 36 0c 37 8c 33 dc 31 d8 30 38 30 f0 30 e0 3f
  80 1f
]];

const BRIGHTNESS_IMAGE = [[
  10 10 80 01 86 61 8e 71 1c 38 d8 1b e0 07 70 0e
  37 ec 37 ec 70 0e e0 07 d8 1b 1c 38 8e 71 86 61
  80 01
]];

const CONTRAST_IMAGE = [[
  10 10 e0 07 f8 1f 3c 3c 0e 70 06 60 07 e0 03 c0
  03 c0 ff ff ff ff ff ff fe 7f fe 7f fc 3f f8 1f
  e0 07
]];

const HUE_SPREAD_IMAGE = [[
  10 10 e0 07 f8 1f 3c 3c 8e 71 c6 63 e7 e7 83 c1
  83 c1 ff ff 7f fe 7f fe 1e 78 3e 7c 7c 3e f8 1f
  e0 07
]];

const BAR_IMAGES = [[
  // BAR_000_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 00
  00 40 01 00 00 00 00 00 00 80 01 00 00 00 00 00
  00 80 01 00 00 00 00 00 00 80 01 00 00 00 00 00
  00 80 02 00 00 00 00 00 00 40 fc ff ff ff ff ff
  ff 3f

  // BAR_125_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 00
  00 7f 01 00 00 00 00 00 00 ff 01 00 00 00 00 00
  00 ff 01 00 00 00 00 00 00 ff 01 00 00 00 00 00
  00 ff 02 00 00 00 00 00 00 7f fc ff ff ff ff ff
  ff 3f

  // BAR_250_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 00
  ff 7f 01 00 00 00 00 00 ff ff 01 00 00 00 00 00
  ff ff 01 00 00 00 00 00 ff ff 01 00 00 00 00 00
  ff ff 02 00 00 00 00 00 ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_375_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 ff
  ff 7f 01 00 00 00 00 ff ff ff 01 00 00 00 00 ff
  ff ff 01 00 00 00 00 ff ff ff 01 00 00 00 00 ff
  ff ff 02 00 00 00 00 ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_500_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 ff ff
  ff 7f 01 00 00 00 ff ff ff ff 01 00 00 00 ff ff
  ff ff 01 00 00 00 ff ff ff ff 01 00 00 00 ff ff
  ff ff 02 00 00 00 ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_625_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 ff ff ff
  ff 7f 01 00 00 ff ff ff ff ff 01 00 00 ff ff ff
  ff ff 01 00 00 ff ff ff ff ff 01 00 00 ff ff ff
  ff ff 02 00 00 ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_750_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 ff ff ff ff
  ff 7f 01 00 ff ff ff ff ff ff 01 00 ff ff ff ff
  ff ff 01 00 ff ff ff ff ff ff 01 00 ff ff ff ff
  ff ff 02 00 ff ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_875_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 ff ff ff ff ff
  ff 7f 01 ff ff ff ff ff ff ff 01 ff ff ff ff ff
  ff ff 01 ff ff ff ff ff ff ff 01 ff ff ff ff ff
  ff ff 02 ff ff ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_1000_IMAGE
  08 40 fc ff ff ff ff ff ff 3f fe ff ff ff ff ff
  ff 7f ff ff ff ff ff ff ff ff ff ff ff ff ff ff
  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
  ff ff fe ff ff ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f
]];

const EMBEDDED_IMAGE = [[
  20 10 00 00 00 00 61 00 81 00 81 4c 81 92 7f 92
  00 92 68 64 94 00 54 04 f8 fe 00 84 3c 00 c0 78
  3c a4 00 94 78 48 a4 00 94 fc 48 08 00 04 ff f8
  00 00 fd 78 00 84 fc 84 08 78 04 00 f8 00 00 00
  00 00
]];

const GEMINI_IMAGE = [[
  20 08 00 00 7e 81 81 91 72 00 78 a4 94 48 00 fc
  04 f8 04 f8 00 fd 00 fc 08 04 f8 00 fd 00 00 00
  00 00
]];

const PLOVER_HID_IMAGE = [[
  20 10 00 00 00 00 00 00 ff 00 11 00 11 00 0e 00
  00 00 ff 00 00 00 78 fe 84 10 84 10 78 fe 00 00
  3c fe c0 00 3c fe 00 82 78 82 a4 7c 94 00 48 00
  00 00 fc 00 08 00 04 00 08 00 00 00 00 00 00 00
  00 00
]];

func init() {
  updateKeyRgb();
  updateUnderglowRgb();
  updateScreenContrast();

  // Disable liatris power light.
  setGpioPin(24, 1);

  updateDisplay0();
  setAutoDraw(0, AUTO_DRAW_NONE);
  setAutoDraw(1, AUTO_DRAW_WPM);
}

const RGB_UPDATE_TIME = 20;
var lastRgbUpdateTime = 0;

func tick() {
  var time = getTime();
  var screenOn = time - lastActionTime <= SCREEN_OFF_TIMEOUT;
  setScreenOn(0, screenOn);
  setScreenOn(1, screenOn);

  if (time - lastRgbUpdateTime >= RGB_UPDATE_TIME) {
    lastRgbUpdateTime = time;
    updateKeyRgb();
  }

  var capsLockStatus = getLedStatus(LED_STATUS_CAPS_LOCK);
  if (capsLockStatus != lastCapsLockStatus)  {
    lastCapsLockStatus = capsLockStatus;
    updateKeyRgb();
    updateDisplay0();
  }

  if (deferredLayerKey) {
    if (getTime() - qwertyPressTimestamp >= KEY_PRESS_TO_LAYER_RELEASE_THRESHOLD) {
      press(deferredLayerKey);
      deferredLayerKey = 0;
      deferredQwertyKey = 0;
    }
  }
}

const HUE_CYCLE_RGB_ORDER = [[
  00
  0c 01
  18 0d 02
  19 0e 03
  1a 0f 04
  1b 10 05
  24 1c 11
  25 1d
  26

  27
  28 1e
  29 1f 12
  20 13 06
  21 14 07
  22 15 08
  23 16 09
  17 0a
  0b
]];

const SPEED_VALUES      = [[ 00 04 08 0c 10 18 20 30 40 ]];
const HUE_SPREAD_VALUES = [[ 00 10 20 28 30 38 40 48 50 ]];
const SATURATION_VALUES = [[ 00 20 40 50 60 68 70 78 80 ]];
const BRIGHTNESS_VALUES = [[ 00 08 10 20 30 40 50 60 80 ]];

func updateKeyRgbHueCycle(hShift, sat, spreadMultiplier, value) {
  for (var i = 0; i < 42; i = i + 1) {
    setHsv(
      HUE_CYCLE_RGB_ORDER[i],
      spreadMultiplier*i + hShift,
      sat,
      value
    );
  }
}

func updateKeyRgb() {
  updateKeyRgbHueCycle(
    getTime() * SPEED_VALUES[speed] + hueShift,
    SATURATION_VALUES[saturation] * 2,
    HUE_SPREAD_VALUES[hueSpread] * 16,
    BRIGHTNESS_VALUES[brightness]
  );

  // if (getLedStatus(LED_STATUS_CAPS_LOCK)) {
  //   setRgb(31, 128, 128, 128);
  // }
}

func setUnderglow(r, g, b) {
  var finalR = r * brightness >> 3;
  var finalG = g * brightness >> 3;
  var finalB = b * brightness >> 3;
  for(var i = 42; i < 54; i = i + 1) {
    setRgb(i, finalR, finalG, finalB);
  }
}

func updateUnderglowRgb() {
  if (layer & STENO_MASK) {
    setUnderglow(64, 64, 64);
  } else {
    setUnderglow(53, 32, 64);
  }
}

func updateScreenContrast() {
  var contrast = 16 + 30 * brightness;
  setScreenContrast(0, contrast);
  setScreenContrast(1, contrast);
}

const ICON_POSITIONS = [[
  08 40 00 00 00 00 00 00
  00 40 10 40 00 00 00 00
  00 40 10 40 08 52 00 00
  00 40 10 40 00 52 10 52
]];

func drawDisplay0NonSteno(layerImage) {
  setAutoDraw(0, AUTO_DRAW_NONE);
  clearDisplay(0);
  drawImage(0, 0, 16, layerImage);

  var iconCount = (isScanCodePressed(SC_L_SHIFT) || isScanCodePressed(SC_R_SHIFT))
    + (isScanCodePressed(SC_L_CTRL) || isScanCodePressed(SC_R_CTRL))
    + (isScanCodePressed(SC_L_ALT) || isScanCodePressed(SC_R_ALT))
    + (isScanCodePressed(SC_L_META) || isScanCodePressed(SC_R_META));
  var positions = ICON_POSITIONS + 8 * (iconCount - 1);

  if (isScanCodePressed(SC_L_SHIFT) || isScanCodePressed(SC_R_SHIFT)) {
    drawImage(0, positions[0], positions[1], SHIFT_IMAGE);
    positions = positions + 2;
  }
  if (isScanCodePressed(SC_L_CTRL) || isScanCodePressed(SC_R_CTRL)) {
    drawImage(0, positions[0], positions[1], CONTROL_IMAGE);
    positions = positions + 2;
  }
  if (isScanCodePressed(SC_L_ALT) || isScanCodePressed(SC_R_ALT)) {
    drawImage(0, positions[0], positions[1], ALT_IMAGE);
    positions = positions + 2;
  }
  if (isScanCodePressed(SC_L_META) || isScanCodePressed(SC_R_META)) {
    drawImage(0, positions[0], positions[1], COMMAND_IMAGE);
  }

  if (wordCaps) {
    drawImage(0, 8, 128-16, SHIFT_IMAGE);
  }
  else if (getLedStatus(LED_STATUS_CAPS_LOCK)) {
    drawImage(0, 8, 128-16, CAPS_LOCK_IMAGE);
  }
}

func updateDisplay0() {
  if (isSettingsLayer()) {
    drawDisplay0NonSteno(SETTINGS_IMAGE);
  } else if (layer & NAV_MASK) {
    drawDisplay0NonSteno(NAVIGATION_IMAGE);
  } else if (layer & FUNCTION_MASK) {
    drawDisplay0NonSteno(FUNCTION_IMAGE);
  } else if (layer & SYMBOL_MASK) {
    drawDisplay0NonSteno(SYMBOL_IMAGE);
  } else if (layer & STENO_MASK) {
    clearDisplay(0);
    drawImage(0, 0, 16, STENO_IMAGE);
  } else {
    drawDisplay0NonSteno(QWERTY_IMAGE);
  }
}

func drawBar(barValue) {
  drawImage(0, 20, 64, BAR_IMAGES + barValue * 66);
}

func drawBrightness() {
  updateDisplay0();
  drawImage(0, 0, 88, BRIGHTNESS_IMAGE);
  drawBar(brightness);
}

func drawSpeed() {
  updateDisplay0();
  drawImage(0, 0, 88, SPEED_IMAGE);
  drawBar(speed);
}

func drawHueSpread() {
  updateDisplay0();
  drawImage(0, 0, 88, HUE_SPREAD_IMAGE);
  drawBar(hueSpread);
}

func drawSaturation() {
  updateDisplay0();
  drawImage(0, 0, 88, CONTRAST_IMAGE);
  drawBar(saturation);
}

func setLayer(value) {
  layer = value;
  updateDisplay0();
}

func isModifierKey(key) var {
  return SC_L_CTRL <= key && key <= SC_R_META;
}

func isWordKey(key) var {
  return SC_A <= key && key <= SC_Z;
}

func isDigitKey(key) var {
  return SC_1 <= key && key <= SC_0;
}

func press(key) {
  if (key == SC_NONE || key == SK_NONE) {
    return;
  }

  if (isInPressAll() && !isModifierKey(key)) {
    return;
  }

  pressCount = pressCount + 1;

  if (key & KEY_STENO) {
    pressStenoKey(key & 0xff);
  } else {
    var display0NeedsUpdate = 0;
    if (wordCaps) {
      if (isWordKey(key) && (key & KEY_SHIFT) == 0) {
        pressScanCode(SC_L_SHIFT);
        display0NeedsUpdate = 1;
      } else if (!isModifierKey(key)
          && key != (SC_MINUS | KEY_SHIFT)
          && key != SC_BACKSPACE
          && !isDigitKey(key)) {
        wordCaps = 0;
        display0NeedsUpdate = 1;
      }
    }
    if (key & KEY_SHIFT) {
      pressScanCode(SC_L_SHIFT);
      display0NeedsUpdate = 1;
    }
    var scanCode = key & 0xff;
    pressScanCode(scanCode);

    if (display0NeedsUpdate || isModifierKey(scanCode)) {
      updateDisplay0();
    }
  }
}

func release(key) {
  if (key == SC_NONE || key == SK_NONE) {
    return;
  }

  if (key & KEY_STENO) {
    releaseStenoKey(key & 0xff);
  } else {
    var display0NeedsUpdate = 0;
    if (wordCaps) {
      if (isWordKey(key) && (key & KEY_SHIFT) == 0) {
        releaseScanCode(SC_L_SHIFT);
        display0NeedsUpdate = 1;
      }
    }
    if (key & KEY_SHIFT) {
      releaseScanCode(SC_L_SHIFT);
      display0NeedsUpdate = 1;
    }
    var scanCode = key & 0xff;
    releaseScanCode(scanCode);

    if (display0NeedsUpdate || isModifierKey(scanCode)) {
      updateDisplay0();
    }
  }
}

func tap(key) {
  press(key);
  release(key);
}

func isSettingsLayer() var {
  return (layer & (SYMBOL_MASK | FUNCTION_MASK)) == (SYMBOL_MASK | FUNCTION_MASK);
}

func handlePress(qwertyKey, stenoKey, symbolsKey, functionKey, navKey) {
  lastActionTime = getTime();
  if (isSettingsLayer()) {
    return;
  } else if (layer & NAV_MASK) {
    if (deferredLayerKey) {
      press(deferredLayerKey);

      deferredLayerKey = 0;
      deferredQwertyKey = 0;

      press(navKey);
    } else if (getTime() - navLayerPressTimestamp < LAYER_PRESS_TO_KEY_PRESS_THRESHOLD) {
      deferredLayerKey = navKey;
      deferredQwertyKey = qwertyKey;
      qwertyPressTimestamp = getTime();
    } else {
      press(navKey);
    }
  } else if (layer & FUNCTION_MASK) {
    if (deferredLayerKey) {
      press(deferredLayerKey);

      deferredLayerKey = 0;
      deferredQwertyKey = 0;

      press(functionKey);
    } else if (getTime() - functionLayerPressTimestamp < LAYER_PRESS_TO_KEY_PRESS_THRESHOLD) {
      deferredLayerKey = functionKey;
      deferredQwertyKey = qwertyKey;
      qwertyPressTimestamp = getTime();
    } else {
      press(functionKey);
    }
  } else if (layer & SYMBOL_MASK) {
    press(symbolsKey);
  } else if (layer & STENO_MASK) {
    press(stenoKey);
  } else {
    press(qwertyKey);
  }
}
func handleRelease(qwertyKey, stenoKey, symbolsKey, functionKey, navKey) {
  lastActionTime = getTime();
  if (isSettingsLayer()) {
    return;
  } else if (layer & NAV_MASK) {
    if (deferredLayerKey) {
      if (isButtonPressed(NAV_BUTTON)) {
        press(deferredLayerKey);
        deferredLayerKey = 0;
        deferredQwertyKey = 0;
      }
    }

    release(navKey);
  } else if (layer & FUNCTION_MASK) {
    if (deferredLayerKey) {
      if (isButtonPressed(FUNCTION_BUTTON)) {
        press(deferredLayerKey);
        deferredLayerKey = 0;
        deferredQwertyKey = 0;
      }
    }

    release(functionKey);
  } else if (layer & SYMBOL_MASK) {
    release(symbolsKey);
  } else if (layer & STENO_MASK) {
    release(stenoKey);
  } else {
    release(qwertyKey);
  }
}

func onPress0() {
  handlePress(SC_TAB, SK_NONE, SC_GRAVE, SC_NONE, SC_NONE);

  if (isSettingsLayer()) {
    sendText(console("get_parameter stroke_count"));
  }
}
func onRelease0() { handleRelease(SC_TAB, SK_NONE, SC_GRAVE, SC_NONE, SC_NONE); }

func onPress1() { handlePress(SC_Q, SK_S1 | KEY_STENO, SC_1, SC_F9, SC_NONE); }
func onRelease1() { handleRelease(SC_Q, SK_S1 | KEY_STENO, SC_1, SC_F9, SC_NONE); }

func onPress2() { handlePress(SC_W, SK_TL | KEY_STENO, SC_2, SC_F10, SC_NONE); }
func onRelease2() { handleRelease(SC_W, SK_TL | KEY_STENO, SC_2, SC_F10, SC_NONE); }

func onPress3() {
  handlePress(SC_E, SK_PL | KEY_STENO, SC_3, SC_F11, SC_NONE);

  if (isSettingsLayer()) {
    console("set_steno_mode embedded");
    updateDisplay0();
    drawImage(0, 0, 112, EMBEDDED_IMAGE);
  }
}
func onRelease3() { handleRelease(SC_E, SK_PL | KEY_STENO, SC_3, SC_F11, SC_NONE); }

func onPress4() { handlePress(SC_R, SK_HL | KEY_STENO, SC_4, SC_F12, SC_NONE); }
func onRelease4() { handleRelease(SC_R, SK_HL | KEY_STENO, SC_4, SC_F12, SC_NONE); }

func onPress5() { handlePress(SC_T, SK_STAR1 | KEY_STENO, SC_5, SC_NONE, SC_NONE); }
func onRelease5() { handleRelease(SC_T, SK_STAR1 | KEY_STENO, SC_5, SC_NONE, SC_NONE); }

func onPress6() {
  handlePress(SC_Y, SK_STAR2 | KEY_STENO, SC_6, SC_NONE, SC_VOLUME_UP);

  if (isSettingsLayer()) {
    if (speed < 8) {
      // Adjust hue to avoid glitches.
      hueShift = hueShift + getTime() * (SPEED_VALUES[speed] - SPEED_VALUES[speed + 1]);

      speed = speed + 1;
    }
    drawSpeed();
  }
}
func onRelease6() { handleRelease(SC_Y, SK_STAR2 | KEY_STENO, SC_6, SC_NONE, SC_VOLUME_UP); }

func onPress7() { handlePress(SC_U, SK_FR | KEY_STENO, SC_7, SC_NONE, SC_BACKSPACE); }
func onRelease7() { handleRelease(SC_U, SK_FR | KEY_STENO, SC_7, SC_NONE, SC_BACKSPACE); }

func onPress8() {
  handlePress(SC_I, SK_PR | KEY_STENO, SC_8, SC_NONE, SC_UP);

  if (isSettingsLayer()) {
    if (brightness < 8) {
      brightness = brightness + 1;
      updateKeyRgb();
      updateUnderglowRgb();
      updateScreenContrast();
    }
    drawBrightness();
  }
}
func onRelease8() { handleRelease(SC_I, SK_PR | KEY_STENO, SC_8, SC_NONE, SC_UP); }

func onPress9() {
  handlePress(SC_O, SK_LR | KEY_STENO, SC_9, SC_NONE, SC_DELETE);

  if (isSettingsLayer()) {
    if (saturation < 8) {
      saturation = saturation + 1;
      updateKeyRgb();
    }
    drawSaturation();
  }
}
func onRelease9() { handleRelease(SC_O, SK_LR | KEY_STENO, SC_9, SC_NONE, SC_DELETE); }

func onPress10() {
  handlePress(SC_P, SK_TR | KEY_STENO, SC_0, SC_NONE, SC_PAGE_UP);

  if (isSettingsLayer()) {
    hueShift = hueShift - 0x800;
  }
}
func onRelease10() { handleRelease(SC_P, SK_TR | KEY_STENO, SC_0, SC_NONE, SC_PAGE_UP); }

func onPress11() {
  handlePress(SC_BACKSPACE, SK_DR | KEY_STENO, SC_EQUAL, SC_NONE, SC_HOME);

  if (isSettingsLayer()) {
    if (hueSpread < 8) {
      hueSpread = hueSpread + 1;
    }
    drawHueSpread();
  }
}
func onRelease11() { handleRelease(SC_BACKSPACE, SK_DR | KEY_STENO, SC_EQUAL, SC_NONE, SC_HOME); }

// 2nd row

var timer12;
var pressCount12;
func onPress12() {
  handlePress(SC_L_CTRL, SK_NONE, SC_GRAVE | KEY_SHIFT, SC_NONE, SC_NONE);
  timer12 = getTime();
  pressCount12 = pressCount;
}
func onRelease12() {
  handleRelease(SC_L_CTRL, SK_NONE, SC_GRAVE | KEY_SHIFT, SC_NONE, SC_NONE);
  if (layer == 0 && pressCount12 == pressCount && getTime() - timer12 < TAP_THRESHOLD) {
    tap(SC_ESC);
  }
}

func onPress13() { handlePress(SC_A, SK_S2 | KEY_STENO, SC_1 | KEY_SHIFT, SC_F5, SC_L_META); }
func onRelease13() { handleRelease(SC_A, SK_S2 | KEY_STENO, SC_1 | KEY_SHIFT, SC_F5, SC_L_META); }

func onPress14() { handlePress(SC_S, SK_KL | KEY_STENO, SC_2 | KEY_SHIFT, SC_F6, SC_L_ALT); }
func onRelease14() { handleRelease(SC_S, SK_KL | KEY_STENO, SC_2 | KEY_SHIFT, SC_F6, SC_L_ALT); }

func onPress15() {
  handlePress(SC_D, SK_WL | KEY_STENO, SC_3 | KEY_SHIFT, SC_F7, SC_L_CTRL);

  if (isSettingsLayer()) {
    console("set_steno_mode gemini");
    updateDisplay0();
    drawImage(0, 0, 116, GEMINI_IMAGE);
  }
}
func onRelease15() { handleRelease(SC_D, SK_WL | KEY_STENO, SC_3 | KEY_SHIFT, SC_F7, SC_L_CTRL); }

func onPress16() { handlePress(SC_F, SK_RL | KEY_STENO, SC_4 | KEY_SHIFT, SC_F8, SC_L_SHIFT); }
func onRelease16() { handleRelease(SC_F, SK_RL | KEY_STENO, SC_4 | KEY_SHIFT, SC_F8, SC_L_SHIFT); }

func onPress17() { handlePress(SC_G, SK_STAR3 | KEY_STENO, SC_5 | KEY_SHIFT, SC_NONE, SC_NONE); }
func onRelease17() { handleRelease(SC_G, SK_STAR3 | KEY_STENO, SC_5 | KEY_SHIFT, SC_NONE, SC_NONE); }

func onPress18() {
  handlePress(SC_H, SK_STAR4 | KEY_STENO, SC_6 | KEY_SHIFT, SC_NONE, SC_VOLUME_DOWN);

  if (isSettingsLayer()) {
    if (speed > 0) {
      // Adjust hue to avoid glitches.
      hueShift = hueShift + getTime() * (SPEED_VALUES[speed] - SPEED_VALUES[speed - 1]);

      speed = speed - 1;
    }
    drawSpeed();
  }
}
func onRelease18() { handleRelease(SC_H, SK_STAR4 | KEY_STENO, SC_6 | KEY_SHIFT, SC_NONE, SC_VOLUME_DOWN); }

func onPress19() { handlePress(SC_J, SK_RR | KEY_STENO, SC_7 | KEY_SHIFT, SC_L_SHIFT, SC_LEFT); }
func onRelease19() { handleRelease(SC_J, SK_RR | KEY_STENO, SC_7 | KEY_SHIFT, SC_L_SHIFT, SC_LEFT); }

func onPress20() {
  handlePress(SC_K, SK_BR | KEY_STENO, SC_8 | KEY_SHIFT, SC_L_CTRL, SC_DOWN);

  if (isSettingsLayer()) {
    if (brightness > 0) {
      brightness = brightness - 1;
      updateKeyRgb();
      updateUnderglowRgb();
      updateScreenContrast();
    }
    drawBrightness();
  }
}
func onRelease20() { handleRelease(SC_K, SK_BR | KEY_STENO, SC_8 | KEY_SHIFT, SC_L_CTRL, SC_DOWN); }

func onPress21() {
  handlePress(SC_L, SK_GR | KEY_STENO, SC_9 | KEY_SHIFT, SC_L_ALT, SC_RIGHT);

  if (isSettingsLayer()) {
    if (saturation > 0) {
      saturation = saturation - 1;
      updateKeyRgb();
    }
    drawSaturation();
  }
}
func onRelease21() { handleRelease(SC_L, SK_GR | KEY_STENO, SC_9 | KEY_SHIFT, SC_L_ALT, SC_RIGHT); }

func onPress22() {
  handlePress(SC_SEMICOLON, SK_SR | KEY_STENO, SC_0 | KEY_SHIFT, SC_L_META, SC_PAGE_DOWN);

  if (isSettingsLayer()) {
    hueShift = hueShift + 0x800;
  }
}
func onRelease22() { handleRelease(SC_SEMICOLON, SK_SR | KEY_STENO, SC_0 | KEY_SHIFT, SC_L_META, SC_PAGE_DOWN); }

func onPress23() {
  handlePress(SC_APOSTROPHE, SK_ZR | KEY_STENO, SC_EQUAL | KEY_SHIFT, SC_NONE, SC_END);

  if (isSettingsLayer()) {
    if (hueSpread > 0) {
      hueSpread = hueSpread - 1;
    }
    drawHueSpread();
  }
}
func onRelease23() { handleRelease(SC_APOSTROPHE, SK_ZR | KEY_STENO, SC_EQUAL | KEY_SHIFT, SC_NONE, SC_END); }

// 3rd row

var timer24;
var wasSteno24;
var pressCount24;
func onPress24() {
  if (isInPressAll()) {
    return;
  }
  lastActionTime = getTime();
  if (layer >> 1) {
    return;
  }
  wasSteno24 = layer & STENO_MASK;
  if (wasSteno24) {
    releaseAll();
    setLayer(layer ^ STENO_MASK);
    pressCount24 = pressCount;
    pressAll();
  } else {
    press(SC_L_SHIFT);
    pressCount24 = pressCount;
  }
  timer24 = getTime();
}
func onRelease24() {
  // Exit early if this was triggered from a releaseAll() script.
  if (isButtonPressed(24)) {
    return;
  }

  lastActionTime = getTime();

  if (wasSteno24) {
    // If the keypress was in steno mode, and other keys were pressed, drop
    // immediately back to steno mode, and drop all masks.
    if (pressCount24 != pressCount || layer) {
      releaseAll();
      setLayer(STENO_MASK);
    }
  } else {
    release(SC_L_SHIFT);

    // A tap of the key turns on steno mode.
    if (layer == 0 && pressCount24 == pressCount && getTime() - timer24 < TAP_THRESHOLD) {
      releaseAll();
      setLayer(layer | STENO_MASK);
    }
  }
  updateUnderglowRgb();
}

func onPress25() { handlePress(SC_Z, SC_NONE, SC_BACKSLASH, SC_F1, SC_NONE); }
func onRelease25() { handleRelease(SC_Z, SC_NONE, SC_BACKSLASH, SC_F1, SC_NONE); }

func onPress26() { handlePress(SC_X, SC_NONE, SC_BACKSLASH | KEY_SHIFT, SC_F2, SC_NONE); }
func onRelease26() { handleRelease(SC_X, SC_NONE, SC_BACKSLASH | KEY_SHIFT, SC_F2, SC_NONE); }

func onPress27() {
  handlePress(SC_C, SC_NONE, SC_MINUS, SC_F3, SC_NONE);

  if (isSettingsLayer()) {
    console("set_steno_mode plover_hid");
    updateDisplay0();
    drawImage(0, 0, 112, PLOVER_HID_IMAGE);
  }
}
func onRelease27() { handleRelease(SC_C, SC_NONE, SC_MINUS, SC_F3, SC_NONE); }

func onPress28() { handlePress(SC_V, SC_NONE, SC_L_BRACKET, SC_F4, SC_NONE); }
func onRelease28() { handleRelease(SC_V, SC_NONE, SC_L_BRACKET, SC_F4, SC_NONE); }

func onPress29() { handlePress(SC_B, SC_NONE, SC_L_BRACKET | KEY_SHIFT, SC_NONE, SC_NONE); }
func onRelease29() { handleRelease(SC_B, SC_NONE, SC_L_BRACKET | KEY_SHIFT, SC_NONE, SC_NONE); }

func onPress30() { handlePress(SC_N, SC_NONE, SC_R_BRACKET | KEY_SHIFT, SC_NONE, SC_MUTE); }
func onRelease30() { handleRelease(SC_N, SC_NONE, SC_R_BRACKET | KEY_SHIFT, SC_NONE, SC_MUTE); }

func onPress31() { handlePress(SC_M, SC_NONE, SC_R_BRACKET, SC_NONE, SC_NONE); }
func onRelease31() { handleRelease(SC_M, SC_NONE, SC_R_BRACKET, SC_NONE, SC_NONE); }

func onPress32() { handlePress(SC_COMMA, SC_NONE, SC_MINUS | KEY_SHIFT, SC_NONE, SC_NONE); }
func onRelease32() { handleRelease(SC_COMMA, SC_NONE, SC_MINUS | KEY_SHIFT, SC_NONE, SC_NONE); }

func onPress33() { handlePress(SC_DOT, SC_NONE, SC_DOT, SC_NONE, SC_NONE); }
func onRelease33() { handleRelease(SC_DOT, SC_NONE, SC_DOT, SC_NONE, SC_NONE); }

func onPress34() { handlePress(SC_SLASH, SC_NONE, SC_SLASH, SC_NONE, SC_NONE); }
func onRelease34() { handleRelease(SC_SLASH, SC_NONE, SC_SLASH, SC_NONE, SC_NONE); }

var timer35;
var releaseTimer35;
var tapCount35;
var pressCount35;
var capsPressed;
func onPress35() {
  handlePress(SC_R_SHIFT, SC_NONE, SC_NONE, SC_NONE, SC_NONE);

  capsPressed = 0;
  if (layer == 0) {
    timer35 = getTime();
    pressCount35 = pressCount;
    if (timer35 - releaseTimer35 < TAP_THRESHOLD) {
      tapCount35 = tapCount35 + 1;
      if (tapCount35 == 1) {
        wordCaps = wordCaps ^ 1;
        updateDisplay0();
      } else if (tapCount35 == 2) {
        pressScanCode(SC_CAPS);
        wordCaps = 0;
        capsPressed = 1;
      }
    } else {
      tapCount35 = 0;
    }
  }
}
func onRelease35() {
  handleRelease(SC_R_SHIFT, SC_NONE, SC_NONE, SC_NONE, SC_NONE);

  if (capsPressed) {
    capsPressed = 0;
    releaseScanCode(SC_CAPS);
  }

  if (layer == 0 && pressCount35 == pressCount && getTime() - timer35 < TAP_THRESHOLD) {
    releaseTimer35 = getTime();
  }
}

// 4th row

func onPress36() { handlePress(SC_L_META, SK_NUM1 | KEY_STENO, SC_L_META, SC_NONE, SC_NONE); }
func onRelease36() { handleRelease(SC_L_META, SK_NUM1 | KEY_STENO, SC_L_META, SC_NONE, SC_NONE); }

var timer37;
var pressCount37;
func onPress37() {
  handlePress(SC_L_ALT, SK_A | KEY_STENO, SC_L_ALT, SC_NONE, SC_NONE);
  timer37 = getTime();
  pressCount37 = pressCount37;
}
func onRelease37() {
  handleRelease(SC_L_ALT, SK_A | KEY_STENO, SC_L_ALT, SC_NONE, SC_NONE);
  if (layer == 0 && pressCount37 == pressCount && getTime() - timer37 < TAP_THRESHOLD) {
    tap(SC_ENTER);
  }
}

var pressCount38;
func onPress38() {
  if (layer != 0) {
    handlePress(SC_NONE, SK_O | KEY_STENO, SC_L_CTRL, SC_NONE, SC_NONE);
  } else {
    pressCount = pressCount + 1;
    releaseAll();
    setLayer(layer | NAV_MASK);
    pressAll();
    navLayerPressTimestamp = getTime();
    pressCount38 = pressCount;
  }
}
func onRelease38() {
  if (layer & NAV_MASK) {
    releaseAll();
    setLayer(layer ^ NAV_MASK);

    if (layer == 0 && pressCount38 == pressCount && getTime() - navLayerPressTimestamp < TAP_THRESHOLD) {
      tap(SC_SPACE);
    }
    tap(deferredQwertyKey);
    deferredLayerKey = 0;
    deferredQwertyKey = 0;
  } else {
    handleRelease(SC_NONE, SK_O | KEY_STENO, SC_L_CTRL, SC_NONE, SC_NONE);
  }
}

func onPress39() { handlePress(SC_SPACE, SK_E | KEY_STENO, SC_NONE, SC_NONE, SC_SPACE); }
func onRelease39() { handleRelease(SC_SPACE, SK_E | KEY_STENO, SC_NONE, SC_NONE, SC_SPACE); }

var pressCount40;
func onPress40() {
  handlePress(SC_NONE, SK_U | KEY_STENO, SC_NONE, SC_NONE, SC_ENTER);
  if ((layer | SYMBOL_MASK) == SYMBOL_MASK) {
    pressCount = pressCount + 1;
    releaseAll();
    setLayer(layer | FUNCTION_MASK);
    pressAll();
    functionLayerPressTimestamp = getTime();
    pressCount40 = pressCount;
  }
}
func onRelease40() {
  handleRelease(SC_NONE, SK_U | KEY_STENO, SC_NONE, SC_NONE, SC_ENTER);
  if (layer & FUNCTION_MASK) {
    releaseAll();
    setLayer(layer ^ FUNCTION_MASK);

    if (layer == 0) {
      if (pressCount40 == pressCount && getTime() - functionLayerPressTimestamp < TAP_THRESHOLD) {
        tap(SC_ENTER);
      }

      tap(deferredQwertyKey);
    }
    deferredLayerKey = 0;
    deferredQwertyKey = 0;
  }
}

func onPress41() {
  if ((layer | FUNCTION_MASK) != FUNCTION_MASK) {
    handlePress(SC_NONE, SK_NUM2 | KEY_STENO, SC_NONE, SC_NONE, SC_NONE);
  } else {
    pressCount = pressCount + 1;
    releaseAll();
    setLayer(layer | SYMBOL_MASK);
    pressAll();
  }
}

func onRelease41() {
  if (layer & SYMBOL_MASK) {
    releaseAll();
    setLayer(layer ^ SYMBOL_MASK);
  } else {
    handleRelease(SC_NONE, SK_NUM2 | KEY_STENO, SC_L_CTRL, SC_NONE, SC_NONE);
  }
}

